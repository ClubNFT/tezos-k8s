# Multicluster Permissioned Chain

This tutorial will walk you through setting up a Tezos based
permissioned blockchain. Upon successful completion of this tutorial
you will have a permissioned chain running with six nodes in 2 clusters in a
peer-to-peer network. This tutorial assumes the use of Minikube.


## Prerequisites

* docker
* minikube
* helm
* python3
* a ZeroTier network and api access token

## Installing prerequisites

This section varies depending on OS.

### Mac w/ homebrew

Make sure homebrew is installed:

``` shell
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
```

Install prerequisites:

``` shell
brew install python3
brew install minikube
brew install helm
```

### Arch Linux

```shell
pacman -Syu && pacman -S python3 minikube kubectl kubectx helm
```

## Ensure minikube is running

``` shell
minikube start
```

## Setting up mkchain

Install the mkchain program:

``` shell
python3 -m venv .venv
source .venv/bin/activate
pip install mkchain
```

Create a ZeroTier network:

* Go to https://my.zerotier.com
* Login with google credentials or create a new account
* Create a new API access token by clicking on the "Generate New
Token" button. Save the generated access token. e.g. "yEflQt726fjXuSUyQ73WqXvAFoijXkLt"
* Go to https://my.zerotier.com/network
* Create a new network by clicking on the "Create a Network"
button. Save the 16 character generated network
id. e.g. "1c33c1ced02a5eee"

Set environment variables so we can access these values with later commands:
``` shell
ZT_TOKEN=yEflQt726fjXuSUyQ73WqXvAFoijXkLt
ZT_NET=1c33c1ced02a5eee
```

Give your private chain a name:

``` shell
CHAIN_NAME=my_chain
```

Set unbuffered IO for python:

``` shell
PYTHONUNBUFFERED=x
```

Run the following command to create the helm configuration and feed it to helm:

``` shell
mkchain --zerotier-network $ZT_NET --zerotier-token $ZT_TOKEN $CHAIN_NAME
helm install $CHAIN_NAME tezos-helm/ -f ${CHAIN_NAME}_values.yaml --namespace tqtezos --create-namespace
```

Your kubernetes cluster will now be running a series of jobs to
perform the following tasks:

* get a zerotier ip
* generate a node identity
* generate a genesis block for your chain
* activate the protocol
* bake the first block
* start the bootstrap-node node and a baker to validate the chain

You can find your node in the tqtezos namespace using kubectl.

``` shell
kubectl -n tqtezos get pods
```

You can view logs for your node using the following command:
``` shell
kubectl -n tqtezos logs -l appType=tezos -c tezos-node -f
```

Congratulations! You now have an operational Tezos based permissioned
chain running one node.

## Add nodes within the cluster

You can configure a self-contained testnet within your cluster with
a number of nodes of your choice by passing `--additional-nodes` to
mkchain generate-constants.

The nodes will establish peer-to-peer connections in a full mesh topology.

If you previously spun up the chain with just one node, you may scale
up your setup to an arbitrary number of nodes by overriding the
--additional-nodes parameter in the values yaml:

```
# ${CHAIN_NAME}_values.yaml
additional_nodes: 3
baker: true
...
```

## Add external nodes to the cluster

Additional nodes can be added to your network by sharing a yaml file
generated by the mkchain command.

The name of this file is: `${CHAIN_NAME}_invite_values.yaml`

Send this file to the recipients you want to invite.

### on the computer of the joining node

The member needs to follow the installation instructions, build the private zerotier container, put the invite file in the mkchain directory, then run:

``` shell
helm install $CHAIN_NAME tezos-helm/ -f ${CHAIN_NAME}_invite_values.yaml
```

At this point additional nodes will be added in a full mesh
topology.

Congratulations! You now have a multi-cluster Tezos based permissioned
chain.

Check that the nodes have matching heads by comparing their hashes:

``` shell
kubectl get pod -n tqtezos -l appType=tezos -o name | while read line; do kubectl -n tqtezos exec $line -c tezos-node -- /usr/local/bin/tezos-client rpc get /chains/main/blocks/head/hash; done
```

## RPC Authentication
You can optionally spin up an RPC authentication server allowing clients with your given permission to make RPC calls:

```shell
mkchain create $CHAIN_NAME --rpc-auth ...
```

### Current authentication flow
The client authenticates themselves and will receive a secret url that allows them to make RPC calls.
- You provide a trusted client with your cluster ip/address and your private tezos chain id.
- To see your chain id:
  ```shell
  kubectl exec -it -n tqtezos deployment/tezos-bootstrap-node -c tezos-node -- tezos-client rpc get /chains/main/chain_id
  ```
  Or use a tool like like [Lens](https://k8slens.dev/) or run `kubectl logs -n tqtezos deployment/tezos-bootstrap-node -c tezos-node` to see the tezos node logs at the top.
- client runs: `scripts/rpc-auth-client.sh --cluster-address $CLUSTER_IP --tz-alias $TZ_ALIAS --chain-id $CHAIN_ID`
- TZ_ALIAS is the alias of a client's tz address secret key. The client's secret key is used to sign some data for the server to then verify.
- If the client is authenticated, the response should contain a secret url such as `http://192.168.64.51/tezos-node-rpc/ffff3eb3d7dd4f6bbff3f2fd096722ae/`
- Client can then make RPC requests:
  - `curl http://192.168.64.51/tezos-node-rpc/ffff3eb3d7dd4f6bbff3f2fd096722ae/chains/main/chain_id`
  - Bug in tezos client v8, so as of version `tezos/tezos:master_08d3405e_20201113152010`:
    - `tezos-client --endpoint http://192.168.64.51/tezos-node-rpc/ffff3eb3d7dd4f6bbff3f2fd096722ae/ rpc get chains/main/chain_id`
